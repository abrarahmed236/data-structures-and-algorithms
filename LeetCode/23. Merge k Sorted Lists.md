# [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)

## Approach

We will be using a priority queue to hold pointers to all the lists provided.
The priority queue is ordered by the `value` of the first element in the list
with the list with the smallest first element being at the top of the priority
queue. From here we will pop the first list from the queue, store the result and
then push the rest of the list to the priority queue.

## Complexity

With total `N` elements in `K` lists.

-   Time: `O(NlogK)`
-   Space: `O(1)`

## Code

```cpp
class Solution {
    struct Compare {
        bool operator()(ListNode *below, ListNode *above) {
            return below->val > above->val;
        }
    };

   public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        priority_queue<ListNode *, vector<ListNode *>, Compare> pq;

        for (ListNode *list : lists) {
            if (list != nullptr) {
                pq.push(list);
            }
        }

        ListNode *head = nullptr;
        ListNode *tail = nullptr;

        if (!pq.empty()) {
            head = pq.top();
            pq.pop();
            if (head->next != nullptr)
                pq.push(head->next);
            tail = head;
        }

        while (!pq.empty()) {
            tail->next = pq.top();
            tail = tail->next;
            pq.pop();
            if (tail->next != nullptr)
                pq.push(tail->next);
        }

        return head;
    }
};
```
