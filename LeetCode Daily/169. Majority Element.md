# [169. Majority Element](https://leetcode.com/problems/majority-element/description/)

## Approach 1: Hash-Map Counter

We can use a counter to count how many times each element is seen and return the most occuring element accordingly.

### Complexity: Hash-Map Counter

- Time: `O(N)`
- Space: `O(N)`

### Code: Hash-Map Counter

```cpp
class Solution {
   public:
    int majorityElement(vector<int> &nums) {
        unordered_map<int, int> counter;
        int major_elem = -1, major_count = -1;
        for (int elem : nums) {
            counter[elem]++;
            if (counter[elem] > major_count) {
                major_count = counter[elem];
                major_elem = elem;
            }
        }
        return major_elem;
    }
};
```

## Approach 2: Single Counter

We could use a single counter too instead of a separate counter for each encountered element. To do this correctly, we rely on the fact that the folowing algorithm will always return the majority element if there is one. Since the majority element will out vote any other element and come out on top if every element gets a single vote.

### Compexity: Single Counter

- Time: `O(N)`
- Space: `O(1)`

### Code: Single Counter

```cpp
class Solution {
   public:
    int majorityElement(vector<int> &nums) {
        int elem = -1, count = 0;
        for (int num : nums) {
            if (count == 0) {
                count = 1;
                elem = num;
            } else if (elem == num) {
                count++;
            } else {
                count--;
            }
        }
        return elem;
    }
};
```
